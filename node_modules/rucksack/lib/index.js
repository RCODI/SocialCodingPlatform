"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var browserify = require("browserify"),
    watchify = require("watchify-with-cache"),
    streamp = require("streamp"),
    ul = require("ul"),
    os = require("os"),
    abs = require("abs"),
    isRemote = require("url-remote"),
    babelify = require("babelify"),
    es2015 = require("babel-preset-es2015"),
    reactify = require("babel-preset-react"),
    noStrictMode = require("babel-plugin-transform-remove-strict-mode"),
    uglifyify = require("uglifyify"),
    CleanCSS = require("clean-css"),
    postcss = require("postcss"),
    watch = require("fwatcher"),
    logger = require("cute-logger"),
    typpy = require("typpy"),
    parseUrl = require("parse-url"),
    atImport = require("postcss-import"),
    postcssUrl = require("postcss-url"),
    postcssClean = require("postcss-clean"),
    idy = require("idy"),
    noop = require("noop6"),
    matchAll = require("match-all"),
    forEach = require("iterate-object"),
    escapeRegex = require("regex-escape"),
    through = require("through2"),
    collapse = require("bundle-collapser/plugin"),
    cssnext = require("postcss-cssnext"),
    path = require("path");

module.exports = function () {

    /**
     * Ruckasck
     * Creates a new instance of `Ruckasck`.
     *
     * @param  {Object} opts The Rucksack options.
     * @return {Object}      The Rucksack instance.
     */
    function Rucksack(opts) {
        var _browserify,
            _this = this;

        _classCallCheck(this, Rucksack);

        opts = this.opts = ul.merge(opts, {
            jsOutput: process.stdout,
            cssOutput: process.stdout,
            jsUrl: "",
            cssUrl: "",
            development: false,
            browserifyCache: {},
            browserifyPackageCache: {},
            plugins: [],
            cacheFile: ".rucksack-cache.json",
            strictMode: false,
            cssUrlHook: noop,
            aliases: {}
        });

        this._watchingCssFiles = {};
        this.scripts = [this.opts.jsUrl];

        this.stylesheets = [this.opts.cssUrl];

        this.cssPaths = [];
        this.cssBlacklist = [];

        if (!opts.development) {
            opts.plugins.push(collapse);
        }

        this.browserify = browserify((_browserify = {
            debug: opts.development,
            packageCache: opts.browserifyPackageCache,
            plugin: opts.plugins,
            cache: opts.cacheFile ? watchify.getCache(opts.cacheFile) : {}
        }, _defineProperty(_browserify, "packageCache", {}), _defineProperty(_browserify, "fullPaths", false), _browserify));

        opts.cacheFile = opts.cacheFile || os.tmpdir() + "/" + idy();
        if (opts.cacheFile) {
            this.browserify = watchify(this.browserify, {
                watch: opts.development,
                cacheFile: opts.cacheFile
            });
        }

        if (opts.development) {
            this.browserify.on("update", function () {
                _this.bundleJS();
            });
        }

        if (opts.development) {
            opts.babelify = false;
            opts.uglify = false;
        }

        var babelPlugins = [];
        if (this.opts.strictMode === false) {
            babelPlugins.push([noStrictMode]);
        }

        this.browserify.transform(babelify, {
            global: true,
            babelrc: false,
            presets: [reactify, es2015],
            plugins: babelPlugins
        });

        var replacements = [];
        forEach(this.opts.aliases, function (target, source) {
            // import ... from "bloggify"
            replacements.push([new RegExp(" from (\"|')" + escapeRegex(source) + "(\"|')", "g"), " from '" + target + "'"]);
            // require("bloggify")
            replacements.push([new RegExp("require\\((\"|')" + escapeRegex(source) + "(\"|')\\)", "g"), "require('" + target + "')"]);
        });

        // Aliases
        this.browserify.transform(function (file) {
            return through(function (buf, enc, next) {
                buf = buf.toString("utf8");
                replacements.forEach(function (_ref) {
                    var _ref2 = _slicedToArray(_ref, 2),
                        source = _ref2[0],
                        target = _ref2[1];

                    buf = buf.replace(source, target);
                });
                this.push(buf);
                next();
            });
        });

        if (opts.uglify !== false) {
            this.browserify = this.browserify.transform({
                global: true
            }, uglifyify);
        }

        this.remote = {
            js: [],
            css: []
        };
    }

    /**
     * add
     * Downloads the script from the resource file.
     *
     * @param  {String} resPath The path of the resource.
     * @param  {String} root    The file's root path.
     */


    _createClass(Rucksack, [{
        key: "add",
        value: function add(resPath, root) {
            var _this2 = this;

            var type = "";
            var inline = false;
            if (typpy(resPath, Object)) {
                if (resPath.type) {
                    type = resPath.type;
                    resPath = resPath.url;
                    inline = resPath.inline;
                } else {
                    this.add(resPath.styles, root);
                    this.add(resPath.scripts, root);
                    return;
                }
            } else if (typpy(resPath, Array)) {
                resPath.forEach(function (c) {
                    return _this2.add(c, root);
                });
                return;
            } else if (!typpy(resPath, String)) {
                return;
            }

            if (!isRemote(resPath) && typpy(root, String)) {
                resPath = root + "/" + resPath;
            }

            if (!type) {
                if (resPath.endsWith(".js")) {
                    type = "js";
                } else if (resPath.endsWith(".css")) {
                    type = "css";
                }
            }

            switch (type) {
                case "js":
                    this.addJS(resPath, inline);
                    break;
                case "css":
                    this.addCSS(resPath, inline);
                    break;
                default:
                    throw new Error("Unknown resource type.");
                    break;
            }
        }

        /**
         * addJS
         * Downloads the JS scripts from the resource.
         *
         * @param  {String} resPath The path of the resource.
         * @param  {Boolean} inline Confirms if the resource needs to be downloaded or not.
         */

    }, {
        key: "addJS",
        value: function addJS(resPath, inline) {
            var pathIsRemote = isRemote(resPath);
            if (pathIsRemote) {
                if (inline === true) {
                    this.remote.js.push(resPath);
                } else {
                    this.scripts.push(resPath);
                }
            } else {
                this.browserify.add(resPath);
            }
        }

        /**
         * _watchCSS
         * Watch the CSS paths.
         *
         * @name _watchCSS
         * @function
         * @param  {String} resPath The CSS resource path.
         */

    }, {
        key: "_watchCSS",
        value: function _watchCSS(resPath) {
            var _this3 = this;

            if (Array.isArray(resPath)) {
                return resPath.forEach(function (c) {
                    return _this3._watchCSS(c);
                });
            }
            resPath = abs(resPath);
            if (this._watchingCssFiles[resPath]) {
                return;
            }
            this._watchingCssFiles[resPath] = watch(resPath, function (err, ev) {
                setTimeout(function () {
                    logger.log("CSS File Updated: " + resPath);
                    _this3.bundleCSS();
                }, 60);
            });
        }

        /**
         * addCSS
         * Adds a new CSS path.
         *
         * @name addCSS
         * @function
         * @param {String} resPath The CSS resource path to add.
         * @param {Boolean} inline Whether to add the CSS content inline or not.
         */

    }, {
        key: "addCSS",
        value: function addCSS(resPath, inline) {
            this._watchCSS(resPath);
            this.cssPaths.push(resPath);
        }

        /**
         * bundleJS
         * Bundles the JS files.
         *
         * @param  {String} output   The output of the JS script.
         * @param  {Function} cb     The callback function.
         */

    }, {
        key: "bundleJS",
        value: function bundleJS(output, cb) {
            var _this4 = this;

            var maybeOutputFileName = output = output || this.opts.jsOutput;
            if (typeof maybeOutputFileName === "string") {
                maybeOutputFileName = path.basename(maybeOutputFileName);
            } else {
                maybeOutputFileName = "";
            }
            var bundling = this.browserify.bundle({
                debug: this.opts.development
            });
            if (!bundling) {
                return cb();
            }
            if (typeof output === "string") {
                output = new streamp.writable(output);
            }
            logger.log("Bundling " + (maybeOutputFileName ? maybeOutputFileName : " the scripts."));
            bundling.on("error", function (e) {
                if (e.codeFrame) {
                    logger.log(e.message + "\n" + e.codeFrame, "error");
                } else {
                    logger.log(e, "error");
                }
            });
            bundling.pipe(output);
            bundling.on("end", function () {
                if (maybeOutputFileName) {
                    logger.log("Bundled: " + maybeOutputFileName);
                }
                _this4.browserify.write();
                cb && cb();
            });
        }

        /**
         * bundleCSS
         * Bundles the CSS files.
         *
         * @param  {String} output   The output of the CSS script.
         * @param  {Function} cb     The callback function.
         * @return {String}          The URL of the script.
         */

    }, {
        key: "bundleCSS",
        value: function bundleCSS(output, cb) {
            var _this5 = this;

            var maybeOutputFileName = output = output || this.opts.cssOutput;
            if (typeof output === "string") {
                output = new streamp.writable(output);
            }

            if (typeof maybeOutputFileName === "string") {
                maybeOutputFileName = path.basename(maybeOutputFileName);
            } else {
                maybeOutputFileName = "";
            }

            var cssImports = this.cssPaths.map(function (c) {
                return "@import url('" + c + "');";
            }).join("\n");

            var cssBundler = postcss();

            var extensions = [atImport({
                root: "/",
                blacklist: this.cssBlacklist,
                onImport: function onImport(paths) {
                    _this5._watchCSS(paths);
                }
            }), [postcssUrl, {
                url: function url(_url, decl, from, dirname, to, options, result) {
                    var newUrl = _this5.opts.cssUrlHook(_url, decl, from, dirname, to, options, result);
                    if (newUrl) {
                        return newUrl;
                    }
                    return _url;
                }
            }], cssnext({
                features: {
                    customProperties: false
                }
            })];

            if (!this.opts.development) {
                extensions.push(postcssClean);
            }

            extensions.forEach(function (c) {
                cssBundler = Array.isArray(c) ? cssBundler.use(c[0](c[1])) : cssBundler = cssBundler.use(c);
            });

            logger.log("Bundling " + (maybeOutputFileName ? maybeOutputFileName : " the styles."));
            return cssBundler.process(cssImports).then(function (result) {
                var messages = result.messages.map(function (c) {
                    return {
                        message: c.text,
                        type: c.type === "warning" ? "warn" : c.type
                    };
                });
                messages.forEach(function (c) {
                    if (c.message) {
                        logger.log(c.message, c.type);
                    }
                });
                output.write(result.css);
                output.on("close", function () {
                    cb && cb();
                });
                if (output !== process.stdout) {
                    if (maybeOutputFileName) {
                        logger.log("Bundled: " + maybeOutputFileName);
                    }
                    output.end();
                }
            }).catch(function (e) {
                logger.log(e, "error");
                cb && cb(e);
            });
        }

        /**
         * bundle
         * Bundles the JS files with the CSS ones.
         * @return {Object}
         */

    }, {
        key: "bundle",
        value: function bundle() {
            var _this6 = this;

            return new Promise(function (res, rej) {
                _this6.bundleJS(null, function (err) {
                    if (err) {
                        return rej(err);
                    }
                    _this6.bundleCSS(null, function (err) {
                        if (err) {
                            return rej(err);
                        }
                        res();
                    });
                });
            });
        }

        /**
         * toObject
         * Creates an array containing each map to the resources.
         *
         * @return {Array}  The resources list.
         */

    }, {
        key: "toObject",
        value: function toObject() {
            var resources = [];
            resources.push.apply(resources, this.scripts.map(function (c) {
                return {
                    type: "script",
                    url: c
                };
            }));
            resources.push.apply(resources, this.stylesheets.map(function (c) {
                return {
                    type: "stylesheet",
                    url: c
                };
            }));
            return resources;
        }

        /**
         * cssHtml - description
         * Generates the HTML markup for CSS.
         * @return {String} The HTML markup.
         */

    }, {
        key: "cssHtml",
        value: function cssHtml() {
            return this.html(this.toObject().filter(function (c) {
                return c.type === "stylesheet";
            }));
        }

        /**
         * jsHtml
         * Generates the HTML markup for JS.
         * @return {String} The HTML markup.
         */

    }, {
        key: "jsHtml",
        value: function jsHtml() {
            return this.html(this.toObject().filter(function (c) {
                return c.type === "script";
            }));
        }

        /**
         * html
         * Loads the HTML script.
         *
         * @param  {Array} resources The resources list.
         * @return {String}          The source of the script or stylesheet.
         */

    }, {
        key: "html",
        value: function html(resources) {
            resources = resources || this.toObject();
            return resources.map(function (c) {
                switch (c.type) {
                    case "script":
                        return "<script src=\"" + c.url + "\"></script>";
                    case "stylesheet":
                        return "<link rel=\"stylesheet\" href=\"" + c.url + "\" />";
                    default:
                        throw new Error("Invalid resource type.");
                }
            }).join("\n");
        }
    }]);

    return Rucksack;
}();